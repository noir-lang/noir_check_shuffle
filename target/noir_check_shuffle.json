{"noir_version":"0.32.0+c679f01a19b02ad2ac2287c8e699b46887f7872c","hash":3869096615597297836,"abi":{"parameters":[{"name":"x","type":{"kind":"array","length":7,"type":{"kind":"field"}},"visibility":"private"},{"name":"y","type":{"kind":"array","length":7,"type":{"kind":"field"}},"visibility":"private"}],"return_type":null,"error_types":{}},"bytecode":"H4sIAAAAAAAA/+2dv3MbRRTHVz9sn3XSSbLlH7Kc+JwYQqCRZFmyuzB0zFDA8A/EWB6YAcwEh5C/gJKCEipmoIGGHhqGghr+BGgYCmooMmgv++Kvl5WiS94eehPdzM3t3e3u++x39967XVlyTj3c9kb7DZMujvbcaF8y5/oYjPbl0V4a7eFoL4/2irm/YI55c8SyCq7p7ZY5tp9u6zDW1fbFmBPAmBfAWBDAWBTAuCCAcZGRMQs/tCRA00AA47IAxpIAxlAAY1kAY0Xx+iFiJH8UjfbqaK+N9vpoXxntq6O9oazNbth+u9/rDQfdYWe/c7vdPTo+PGj3Do77h53DzsHhwUn3cH9/eNg7HBwdHw3aR53e/rBzenC0f2pg1hgbpoNeARq1NmFXJm9B/Xfj4hmnWfvptk4kgHHdA6MoUO4HZUPxvsF6HPgdX30lYeBvcDIWANBDRz3THmpTefJQeQv0aZ/8WW201PBZFcDYVEpG+OQElRqWJAyoeVgS0lFbSkhYYlxOZm201LBUE8DYUkLCEieo1LAkYUDNw5KQjtpWQsIS4yeIrI2WGpbqAhivKCFhiRNUaliSMKDmYUlIR11VQsIS4x+NsDZaalhaEcC4o4SEJU5QqWFJwoCahyUhHRUrIWGJ8e8EWRstNSytCmDcVULCEieo1LAkYUDNw5KQjrqmhIQlxj8NZ2201LDUEMB4XQkJS5ygUr2dhAG1p4R4O8YvmbA2WndI0dQVQftzRoOCua+9tW7D476Yh9sS1EUd/zncb5rjy3fu3L4fv/P+yfDj+OzueXx2Gh+f3X3/5EMs+NWTFvzmSQt+/6QFf3vSgiG4iW1zvH1+Pnzvg/P4/Cy+fXIS33vn/O347KPhndN3z+5h2dfz6co+KvimKRgAdayYRtjo4ViEynGE0eU8u812W9db4K7XfK2pyM870PUueODVT+eiqYt0DiG9CNcoXYRrRSuffqK3oO88aDH0pEWi8ZKnMRHw15t45mVT14KpO4Bz6oOSSXP+rRbaJidDdpZhnFC6CXkpH+mRB1a96UhB46k0oVzRKhdBnkUoZ/stOqe+1lpVTVp/3BUFl+/7GhearWCxFVR2thcs2wsO2x7GbTdU478CizwKOOhY4ucZhOryGHkcTwl4lvl5Op7amcS80NT1QPH6obKlVWBpFUGeEPQre9DP5SvonOzNmefMc+Y5c1pmzYPxkbgo39KMMNrvYp54uqHFo7dJsbMMPBE/zyBUl8fU43gi4Knw83Q8tTOJ5VVoH1e9uq6apVXZ0iqCPFXQr+ZBv5y6vCYQw3kN2j9nnjPPmefMaZgxTuI7BuUrzQgjXasAj4+Ygmt8VL9eE7gLdj2sBwxc61iLYFNvuJb0CeS9D9rgGqTeQiiD72Ue5taX1sOobjovASO1B9/LfK8t5dT4tSUfa+C4tkS26bwAfUPXcI3ZXtPDtegFuEb1FEFPXN+IGduTdn0I5ykh5L/Fw9OO1GV9yJaH9/s2PkNl6IdP/dpNfEII9mIHRxHyfAZ5q6ZzKnC/BHpVrGue/GnyHOCnnjGco08vQ9ojT6JpdYymEWhKeb4wR4zrtGFdxElaL0N7qE0Y7z08Ex1cS8iZPQQOahvl+RJ0KOYu2HyNZfxZWl03+Twcy5Tna3Mcp7s9puzP6iqOtvtsW2S1zfWcUp5vH9M2+30I/Tu1x36GlMXg6ne6/x3kK0C/+xiTLj+Nzzu+p0TWNZzfxyqbd86qGq9xHtLUFw8MZ52fMxlXK6Yu+5khe0XI84M5usZVAPliRkZPbU/6aBXaGEN/YNspz4+g008mrccU9SfG7V8d92mb9E6zAlqueWizrnedv95kPWsD2h+DHWzTJmjA1Sa0TTGJ7ND1IqR/gbyUj/SgPiR2PR7oZzk3J5SrWuUiyNOAcutWOTqnvtba/QxpGkc+58aNMW3BOWoD0nQkH0r5x/lXH+u9k/wr+lR7nl+BdMnBXZoB7gpoiuvmvt4rbP/veq+gPL9beuLm0//7+ozH9v9VR9spzx+g058mjWOnBvf/cdynbe7//1///zfktf049WFa/x9Z5Z7G//8FaRpHPv1RY0xbcM5KeUK4hp8d0z16frJY07XnxXSOa7r4rk2a0nwE56Q4l8O10EfthTJLfuexHZxTU922T8b56aKVJwR+ylPOXdYGt9BRFtee7LUeXFOlo6+1BuyLnIPTzxpOr/ssfr7N968i+vtaK2mfUwVWmsd2/1Dbrk+hRd3B42veO06LusM2oxYH+L45SYsVB4+Hd8uJWpC9tMzVGWAOrDSP7f4xvjNP0mLVwbOasRarDtt8Whycut6dXFo0HDyNjLVoOGzzaTFI/P3aFFqsOXh8zHMmaUH20jLXZoA5sNI8tgcHrrmJS4t1B4+H+eRELdYdthl9XB/nk5O02HDwbGSsBc57pTEHVprHdv+tSeu6qMWmg2czYy0mrSlMYq7PAHNgpXlsd5P+a06hRdPB08xYi6bDNqMWybra1hRabDl4tjLWguylZd4QyFwTyNwQyDwL4zmw0jy2+4nt1hRatBw8rYy1aDlsM2ox1La3p9Bi28GznbEW2w7bjFr0tO0rU2hxxcFzJWMtyF5a5uYMMAdWmsf2oKttX51Ci6sOnqsZa0H20jLXBDI3BDI3BTJvCWSW+AxKZJ6FsRFYaR7bgyNte2cKLXYcPDsZa0H20jI3BDI3BTJvzwBzYKV5bPeTz03iKbSIHTxxxlqQvbTMTYHMLYHMszA2AivNY3uQzAN3p9Bi18Gzm7EWZC8tc1Mgc1Ug845A5pZA5lgg89YMMAdWmsd2P3knvzaFFtccPNcy1oLspWVuCWRuCmSuzwBzYKV5bA8S29en0OK6g+d6xlqQvbTMawKZd2eAObDSPLYHyd/Z7E2hxZ6DZy9jLcheWuYtgcwbApnrAplbApljgcxNgcxzX5cNs0RftyaQWaJ/bswAc1FdfAfutbxPnt5+2u8qE0MI6Qg0e86kbyne3+QiW8+BrefZ9XjYP/Z4ofPnvdrudXW9L3hok673Jn+9yd+pvmjqou9/33Ro9ZJJ55j76UWoNwd26HoR0q/mL/JSPtKD/AGx6+9y3jBpZLfL7VnlIshzA8rdtMrROfV18r/44Dn3MbamGdc1dfEsv6IueAJ2HvdvOtq/S6nz0PO+aOXB/4NCed7IX7TD3kJHWfz9zX8BZFehXxejAAA=","debug_symbols":"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","file_map":{"4":{"source":"// docs:start:eq-trait\ntrait Eq {\n    fn eq(self, other: Self) -> bool;\n}\n// docs:end:eq-trait\n\nimpl Eq for Field { fn eq(self, other: Field) -> bool { self == other } }\n\nimpl Eq for u64 { fn eq(self, other: u64) -> bool { self == other } }\nimpl Eq for u32 { fn eq(self, other: u32) -> bool { self == other } }\nimpl Eq for u8 { fn eq(self, other: u8) -> bool { self == other } }\nimpl Eq for u1 { fn eq(self, other: u1) -> bool { self == other } }\n\nimpl Eq for i8 { fn eq(self, other: i8) -> bool { self == other } }\nimpl Eq for i32 { fn eq(self, other: i32) -> bool { self == other } }\nimpl Eq for i64 { fn eq(self, other: i64) -> bool { self == other } }\n\nimpl Eq for () { fn eq(_self: Self, _other: ()) -> bool { true } }\nimpl Eq for bool { fn eq(self, other: bool) -> bool { self == other } }\n\nimpl<T, let N: u32> Eq for [T; N] where T: Eq {\n    fn eq(self, other: [T; N]) -> bool {\n        let mut result = true;\n        for i in 0 .. self.len() {\n            result &= self[i].eq(other[i]);\n        }\n        result\n    }\n}\n\nimpl<T> Eq for [T] where T: Eq {\n    fn eq(self, other: [T]) -> bool {\n        let mut result = self.len() == other.len();\n        for i in 0 .. self.len() {\n            result &= self[i].eq(other[i]);\n        }\n        result\n    }\n}\n\nimpl<let N: u32> Eq for str<N> {\n    fn eq(self, other: str<N>) -> bool {\n        let self_bytes = self.as_bytes();\n        let other_bytes = other.as_bytes();\n        self_bytes == other_bytes\n    }\n}\n\nimpl<A, B> Eq for (A, B) where A: Eq, B: Eq {\n    fn eq(self, other: (A, B)) -> bool {\n        self.0.eq(other.0) & self.1.eq(other.1)\n    }\n}\n\nimpl<A, B, C> Eq for (A, B, C) where A: Eq, B: Eq, C: Eq {\n    fn eq(self, other: (A, B, C)) -> bool {\n        self.0.eq(other.0) & self.1.eq(other.1) & self.2.eq(other.2)\n    }\n}\n\nimpl<A, B, C, D> Eq for (A, B, C, D) where A: Eq, B: Eq, C: Eq, D: Eq {\n    fn eq(self, other: (A, B, C, D)) -> bool {\n        self.0.eq(other.0) & self.1.eq(other.1) & self.2.eq(other.2) & self.3.eq(other.3)\n    }\n}\n\nimpl<A, B, C, D, E> Eq for (A, B, C, D, E) where A: Eq, B: Eq, C: Eq, D: Eq, E: Eq {\n    fn eq(self, other: (A, B, C, D, E)) -> bool {\n        self.0.eq(other.0) & self.1.eq(other.1) & self.2.eq(other.2) & self.3.eq(other.3) & self.4.eq(other.4)\n    }\n}\n\nimpl Eq for Ordering {\n    fn eq(self, other: Ordering) -> bool {\n        self.result == other.result\n    }\n}\n\n// Noir doesn't have enums yet so we emulate (Lt | Eq | Gt) with a struct\n// that has 3 public functions for constructing the struct.\nstruct Ordering {\n    result: Field,\n}\n\nimpl Ordering {\n    // Implementation note: 0, 1, and 2 for Lt, Eq, and Gt are built\n    // into the compiler, do not change these without also updating\n    // the compiler itself!\n    pub fn less() -> Ordering {\n        Ordering { result: 0 }\n    }\n\n    pub fn equal() -> Ordering {\n        Ordering { result: 1 }\n    }\n\n    pub fn greater() -> Ordering {\n        Ordering { result: 2 }\n    }\n}\n\n// docs:start:ord-trait\ntrait Ord {\n    fn cmp(self, other: Self) -> Ordering;\n}\n// docs:end:ord-trait\n\n// Note: Field deliberately does not implement Ord\n\nimpl Ord for u64 {\n    fn cmp(self, other: u64) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for u32 {\n    fn cmp(self, other: u32) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for u8 {\n    fn cmp(self, other: u8) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i8 {\n    fn cmp(self, other: i8) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i32 {\n    fn cmp(self, other: i32) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i64 {\n    fn cmp(self, other: i64) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for () {\n    fn cmp(_self: Self, _other: ()) -> Ordering {\n        Ordering::equal()\n    }\n}\n\nimpl Ord for bool {\n    fn cmp(self, other: bool) -> Ordering {\n        if self {\n            if other {\n                Ordering::equal()\n            } else {\n                Ordering::greater()\n            }\n        } else {\n            if other {\n                Ordering::less()\n            } else {\n                Ordering::equal()\n            }\n        }\n    }\n}\n\nimpl<T, let N: u32> Ord for [T; N] where T: Ord {\n    // The first non-equal element of both arrays determines\n    // the ordering for the whole array.\n    fn cmp(self, other: [T; N]) -> Ordering {\n        let mut result = Ordering::equal();\n        for i in 0 .. self.len() {\n            if result == Ordering::equal() {\n                let result_i = self[i].cmp(other[i]);\n\n                if result_i == Ordering::less() {\n                    result = result_i;\n                } else if result_i == Ordering::greater() {\n                    result = result_i;\n                }\n            }\n        }\n        result\n    }\n}\n\nimpl<T> Ord for [T] where T: Ord {\n    // The first non-equal element of both arrays determines\n    // the ordering for the whole array.\n    fn cmp(self, other: [T]) -> Ordering {\n        let mut result = self.len().cmp(other.len());\n        for i in 0 .. self.len() {\n            if result == Ordering::equal() {\n                let result_i = self[i].cmp(other[i]);\n\n                if result_i == Ordering::less() {\n                    result = result_i;\n                } else if result_i == Ordering::greater() {\n                    result = result_i;\n                }\n            }\n        }\n        result\n    }\n}\n\nimpl<A, B> Ord for (A, B) where A: Ord, B: Ord {\n    fn cmp(self, other: (A, B)) -> Ordering {\n        let result = self.0.cmp(other.0);\n\n        if result != Ordering::equal() {\n            result\n        } else {\n            self.1.cmp(other.1)\n        }\n    }\n}\n\nimpl<A, B, C> Ord for (A, B, C) where A: Ord, B: Ord, C: Ord {\n    fn cmp(self, other: (A, B, C)) -> Ordering {\n        let mut result = self.0.cmp(other.0);\n\n        if result == Ordering::equal() {\n            result = self.1.cmp(other.1);\n        }\n\n        if result == Ordering::equal() {\n            result = self.2.cmp(other.2);\n        }\n\n        result\n    }\n}\n\nimpl<A, B, C, D> Ord for (A, B, C, D) where A: Ord, B: Ord, C: Ord, D: Ord {\n    fn cmp(self, other: (A, B, C, D)) -> Ordering {\n        let mut result = self.0.cmp(other.0);\n\n        if result == Ordering::equal() {\n            result = self.1.cmp(other.1);\n        }\n\n        if result == Ordering::equal() {\n            result = self.2.cmp(other.2);\n        }\n\n        if result == Ordering::equal() {\n            result = self.3.cmp(other.3);\n        }\n\n        result\n    }\n}\n\nimpl<A, B, C, D, E> Ord for (A, B, C, D, E) where A: Ord, B: Ord, C: Ord, D: Ord, E: Ord {\n    fn cmp(self, other: (A, B, C, D, E)) -> Ordering {\n        let mut result = self.0.cmp(other.0);\n\n        if result == Ordering::equal() {\n            result = self.1.cmp(other.1);\n        }\n\n        if result == Ordering::equal() {\n            result = self.2.cmp(other.2);\n        }\n\n        if result == Ordering::equal() {\n            result = self.3.cmp(other.3);\n        }\n\n        if result == Ordering::equal() {\n            result = self.4.cmp(other.4);\n        }\n\n        result\n    }\n}\n\n// Compares and returns the maximum of two values.\n//\n// Returns the second argument if the comparison determines them to be equal.\n//\n// # Examples\n//\n// ```\n// use std::cmp;\n//\n// assert_eq(cmp::max(1, 2), 2);\n// assert_eq(cmp::max(2, 2), 2);\n// ```\npub fn max<T>(v1: T, v2: T) -> T where T: Ord {\n    if v1 > v2 { v1 } else { v2 }\n}\n\n// Compares and returns the minimum of two values.\n//\n// Returns the first argument if the comparison determines them to be equal.\n//\n// # Examples\n//\n// ```\n// use std::cmp;\n//\n// assert_eq(cmp::min(1, 2), 1);\n// assert_eq(cmp::min(2, 2), 2);\n// ```\npub fn min<T>(v1: T, v2: T) -> T where T: Ord {\n    if v1 > v2 { v2 } else { v1 }\n}\n\nmod cmp_tests {\n    use crate::cmp::{min, max};\n\n    #[test]\n    fn sanity_check_min() {\n        assert_eq(min(0 as u64, 1 as u64), 0);\n        assert_eq(min(0 as u64, 0 as u64), 0);\n        assert_eq(min(1 as u64, 1 as u64), 1);\n        assert_eq(min(255 as u8, 0 as u8), 0);\n    }\n\n    #[test]\n    fn sanity_check_max() {\n        assert_eq(max(0 as u64, 1 as u64), 1);\n        assert_eq(max(0 as u64, 0 as u64), 0);\n        assert_eq(max(1 as u64, 1 as u64), 1);\n        assert_eq(max(255 as u8, 0 as u8), 255);\n    }\n}\n","path":"std/cmp.nr"},"53":{"source":"unconstrained fn get_shuffle_indices<T, let N: u32>(\n    lhs: [T; N],\n    rhs: [T; N]\n) -> [Field; N] where T: std::cmp::Eq {\n    let mut shuffle_indices: [Field;N ] = [0; N];\n\n    let mut shuffle_mask: [bool; N] = [false; N];\n    for i in 0..N {\n        let mut found = false;\n        for j in 0..N {\n            if (shuffle_mask[j] == false) {\n                if (lhs[i] == rhs[j]) {\n                    found = true;\n                    shuffle_indices[i] = j as Field;\n                    shuffle_mask[j] = true;\n                }\n            }\n            if (found) {\n                break;\n            }\n        }\n        assert(found == true, \"check_shuffle, lhs and rhs arrays do not contain equivalent values\");\n    }\n\n    shuffle_indices\n}\n\n// 10 = 192\n// 11 = 211\nglobal S = 7;\nfn main(x: [Field; S], y: [Field; S]) {\n    check_shuffle(x, y);\n}\n\npub fn check_shuffle<T, let N: u32>(lhs: [T; N], rhs: [T; N]) where T: std::cmp::Eq {\n    let shuffle_indices = get_shuffle_indices(lhs, rhs);\n    let mut index_masks: [Field; N] = [0; N];\n\n    for i in 0..N {\n        let idx = shuffle_indices[i];\n        assert_eq(index_masks[idx], 0);\n        index_masks[idx] = 1;\n        let expected = rhs[idx];\n        let result = lhs[i];\n        assert_eq(expected, result);\n    }\n}\n\nmod test {\n    struct CompoundStruct {\n        a: bool,\n        b: Field,\n        c: u64\n    }\n    impl std::cmp::Eq for CompoundStruct {\n        fn eq(self, other: Self) -> bool {\n            (self.a == other.a) & (self.b == other.b) & (self.c == other.c)\n        }\n    }\n\n    use crate::check_shuffle;\n    #[test]\n    fn test_shuffle() {\n        let lhs: [Field; 5] = [0, 1, 2, 3, 4];\n        let rhs: [Field; 5] = [2, 0, 3, 1, 4];\n        check_shuffle(lhs, rhs);\n    }\n\n    #[test]\n    fn test_shuffle_identity() {\n        let lhs: [Field; 5] = [0, 1, 2, 3, 4];\n        let rhs: [Field; 5] = [0, 1, 2, 3, 4];\n        check_shuffle(lhs, rhs);\n    }\n\n    #[test(should_fail_with = \"check_shuffle, lhs and rhs arrays do not contain equivalent values\")]\n    fn test_shuffle_fail() {\n        let lhs: [Field; 5] = [0, 1, 2, 3, 4];\n        let rhs: [Field; 5] = [0, 1, 2, 3, 5];\n        check_shuffle(lhs, rhs);\n    }\n\n    #[test(should_fail_with = \"check_shuffle, lhs and rhs arrays do not contain equivalent values\")]\n    fn test_shuffle_duplicates() {\n        let lhs: [Field; 5] = [0, 1, 2, 3, 4];\n        let rhs: [Field; 5] = [0, 1, 2, 3, 3];\n        check_shuffle(lhs, rhs);\n    }\n\n    #[test]\n    fn test_shuffle_compound_struct() {\n        let lhs: [CompoundStruct; 5] = [\n            CompoundStruct { a: false, b: 0, c: 12345 },\n            CompoundStruct { a: false, b: -100, c: 54321 },\n            CompoundStruct { a: true, b: 5, c: 0xffffffffffffffff },\n            CompoundStruct { a: true, b: 9814, c: 0xeeffee0011001133 },\n            CompoundStruct { a: false, b: 0x155, c: 0 }\n        ];\n        let rhs: [CompoundStruct; 5] = [\n            CompoundStruct { a: false, b: 0x155, c: 0 },\n            CompoundStruct { a: false, b: 0, c: 12345 },\n            CompoundStruct { a: false, b: -100, c: 54321 },\n            CompoundStruct { a: true, b: 9814, c: 0xeeffee0011001133 },\n            CompoundStruct { a: true, b: 5, c: 0xffffffffffffffff }\n        ];\n        check_shuffle(lhs, rhs);\n    }\n}\n","path":"/Users/zac/noir_check_shuffle/src/main.nr"}},"names":["main"]}